"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[4412],{7378(e,n,i){i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"modules/ros2-textbook/chapter-2-communication","title":"Chapter 2: ROS 2 Communication Model","description":"Learning Objectives","source":"@site/docs/modules/ros2-textbook/chapter-2-communication.md","sourceDirName":"modules/ros2-textbook","slug":"/modules/ros2-textbook/chapter-2-communication","permalink":"/Hackathons/docs/modules/ros2-textbook/chapter-2-communication","draft":false,"unlisted":false,"editUrl":"https://github.com/muslim785/Hackathons/tree/main/docs/modules/ros2-textbook/chapter-2-communication.md","tags":[],"version":"current","frontMatter":{},"sidebar":"docs","previous":{"title":"Chapter 1: Physical AI and ROS 2 Foundations","permalink":"/Hackathons/docs/modules/ros2-textbook/chapter-1-foundations"},"next":{"title":"Chapter 3: Python AI Agents and rclpy","permalink":"/Hackathons/docs/modules/ros2-textbook/chapter-3-python-integration"}}');var o=i(4848),t=i(8453);const r={},c="Chapter 2: ROS 2 Communication Model",a={},l=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Main Content",id:"main-content",level:2},{value:"Nodes and Execution Graphs",id:"nodes-and-execution-graphs",level:3},{value:"Topics: Asynchronous Communication",id:"topics-asynchronous-communication",level:3},{value:"Services: Synchronous Communication",id:"services-synchronous-communication",level:3},{value:"Actions: Synchronous with Feedback",id:"actions-synchronous-with-feedback",level:3},{value:"Communication Pattern Selection",id:"communication-pattern-selection",level:3},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Node",id:"node",level:3},{value:"Topic",id:"topic",level:3},{value:"Service",id:"service",level:3},{value:"Action",id:"action",level:3},{value:"Execution Graph",id:"execution-graph",level:3},{value:"Humanoid-Specific Examples",id:"humanoid-specific-examples",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2},{value:"Further Reading",id:"further-reading",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"chapter-2-ros-2-communication-model",children:"Chapter 2: ROS 2 Communication Model"})}),"\n",(0,o.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Understand the fundamental ROS 2 communication patterns: nodes, topics, services, and actions"}),"\n",(0,o.jsx)(n.li,{children:"Explain the differences between asynchronous (topics) and synchronous (services, actions) communication"}),"\n",(0,o.jsx)(n.li,{children:"Describe how execution graphs organize ROS 2 components"}),"\n",(0,o.jsx)(n.li,{children:"Apply appropriate communication patterns to humanoid robot sensor and actuator scenarios"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(n.p,{children:"In this chapter, we'll explore the core communication mechanisms that make ROS 2 powerful for robotics applications. You'll learn how different components of a robot system communicate with each other through nodes, topics, services, and actions. Understanding these patterns is essential for designing effective robotic systems, particularly for humanoid robots with complex sensorimotor requirements."}),"\n",(0,o.jsx)(n.h2,{id:"main-content",children:"Main Content"}),"\n",(0,o.jsx)(n.h3,{id:"nodes-and-execution-graphs",children:"Nodes and Execution Graphs"}),"\n",(0,o.jsxs)(n.p,{children:["In ROS 2, a ",(0,o.jsx)(n.strong,{children:"node"})," is a process that performs computation. Nodes are the fundamental building blocks of a ROS 2 system. Each node typically handles a specific task, such as sensor data processing, control algorithm execution, or user interface management."]}),"\n",(0,o.jsxs)(n.p,{children:["Nodes organize into an ",(0,o.jsx)(n.strong,{children:"execution graph"}),", which represents the structure and communication flow of your robotic system. This graph shows:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Which nodes exist in your system"}),"\n",(0,o.jsx)(n.li,{children:"How nodes communicate with each other"}),"\n",(0,o.jsx)(n.li,{children:"The flow of data between components"}),"\n",(0,o.jsx)(n.li,{children:"Dependencies between different system components"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The execution graph is dynamic - nodes can be added, removed, or reconfigured while the system runs, providing flexibility for different robot configurations and operational modes."}),"\n",(0,o.jsx)(n.h3,{id:"topics-asynchronous-communication",children:"Topics: Asynchronous Communication"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Topics"})," provide asynchronous, many-to-many communication in ROS 2. They follow a publish-subscribe pattern where:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Publishers send messages to a topic without knowing who will receive them"}),"\n",(0,o.jsx)(n.li,{children:"Subscribers receive messages from a topic without knowing who sent them"}),"\n",(0,o.jsx)(n.li,{children:"Multiple publishers can send to the same topic"}),"\n",(0,o.jsx)(n.li,{children:"Multiple subscribers can receive from the same topic"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Topics are ideal for:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Sensor data distribution (e.g., camera images, laser scans)"}),"\n",(0,o.jsx)(n.li,{children:"Continuous state updates (e.g., robot position, joint angles)"}),"\n",(0,o.jsx)(n.li,{children:"Event notifications (e.g., button presses, obstacle detection)"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"The asynchronous nature means publishers and subscribers don't need to run simultaneously - messages are queued until subscribers are available."}),"\n",(0,o.jsx)(n.h3,{id:"services-synchronous-communication",children:"Services: Synchronous Communication"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Services"})," provide synchronous, request-response communication between two nodes. This pattern involves:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A client node sends a request to a service"}),"\n",(0,o.jsx)(n.li,{children:"A server node processes the request and sends a response back"}),"\n",(0,o.jsx)(n.li,{children:"The client waits for the response before continuing"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Services are appropriate for:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Operations with a clear beginning and end"}),"\n",(0,o.jsx)(n.li,{children:"Requesting specific computations (e.g., path planning, image processing)"}),"\n",(0,o.jsx)(n.li,{children:"Configuration changes that require confirmation"}),"\n",(0,o.jsx)(n.li,{children:"Any operation where the client needs to know the result before proceeding"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"actions-synchronous-with-feedback",children:"Actions: Synchronous with Feedback"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Actions"})," are goal-oriented communications that provide feedback during execution and can be canceled. They combine features of both topics and services:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A client sends a goal to an action server"}),"\n",(0,o.jsx)(n.li,{children:"The server provides feedback about progress during execution"}),"\n",(0,o.jsx)(n.li,{children:"The client can cancel the goal before completion"}),"\n",(0,o.jsx)(n.li,{children:"The server returns a result when the goal completes"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Actions are perfect for:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Long-running operations (e.g., navigation to a distant location)"}),"\n",(0,o.jsx)(n.li,{children:"Tasks where progress monitoring is important (e.g., arm trajectory execution)"}),"\n",(0,o.jsx)(n.li,{children:"Operations that might need interruption (e.g., emergency stops)"}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"communication-pattern-selection",children:"Communication Pattern Selection"}),"\n",(0,o.jsx)(n.p,{children:"Choosing the right communication pattern depends on your specific use case:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use Topics"})," when you need:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Continuous data flow"}),"\n",(0,o.jsx)(n.li,{children:"Multiple subscribers to the same information"}),"\n",(0,o.jsx)(n.li,{children:"Decoupled timing between publishers and subscribers"}),"\n",(0,o.jsx)(n.li,{children:"Example: Publishing camera images for multiple vision algorithms"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use Services"})," when you need:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A specific response to a request"}),"\n",(0,o.jsx)(n.li,{children:"Confirmation that an operation completed"}),"\n",(0,o.jsx)(n.li,{children:"Synchronous behavior"}),"\n",(0,o.jsx)(n.li,{children:"Example: Requesting a map from a mapping service"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Use Actions"})," when you need:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Long-running operations with progress feedback"}),"\n",(0,o.jsx)(n.li,{children:"Ability to cancel operations"}),"\n",(0,o.jsx)(n.li,{children:"Asynchronous behavior with result guarantees"}),"\n",(0,o.jsx)(n.li,{children:"Example: Moving a robot arm to a specific position with progress updates"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,o.jsx)(n.h3,{id:"node",children:"Node"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"node"})," is a process that performs computation in ROS 2. Nodes are organized into packages to form a ROS system. Each node typically handles a specific task or function."]}),"\n",(0,o.jsx)(n.h3,{id:"topic",children:"Topic"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"topic"})," is an asynchronous, many-to-many communication mechanism in ROS 2. Multiple nodes can publish to or subscribe to the same topic without direct knowledge of each other."]}),"\n",(0,o.jsx)(n.h3,{id:"service",children:"Service"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.strong,{children:"service"})," is a synchronous, request-response communication pattern in ROS 2 between two nodes. The client waits for a response from the service server."]}),"\n",(0,o.jsx)(n.h3,{id:"action",children:"Action"}),"\n",(0,o.jsxs)(n.p,{children:["An ",(0,o.jsx)(n.strong,{children:"action"})," is a goal-oriented communication pattern that provides feedback during execution and can be canceled. It's ideal for long-running operations."]}),"\n",(0,o.jsx)(n.h3,{id:"execution-graph",children:"Execution Graph"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.strong,{children:"execution graph"})," represents the structure and communication flow of a ROS 2 system, showing how nodes connect and communicate with each other."]}),"\n",(0,o.jsx)(n.h2,{id:"humanoid-specific-examples",children:"Humanoid-Specific Examples"}),"\n",(0,o.jsx)(n.p,{children:"Consider a humanoid robot performing a reaching task:"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Topics"})," for continuous monitoring:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Joint position sensors publish to ",(0,o.jsx)(n.code,{children:"/joint_states"})," for multiple controllers to monitor"]}),"\n",(0,o.jsxs)(n.li,{children:["IMU data publishes to ",(0,o.jsx)(n.code,{children:"/imu/data"})," for balance and orientation systems"]}),"\n",(0,o.jsxs)(n.li,{children:["Camera images publish to ",(0,o.jsx)(n.code,{children:"/camera/image_raw"})," for vision processing nodes"]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Services"})," for discrete operations:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"A trajectory planner service accepts requests to compute joint trajectories"}),"\n",(0,o.jsx)(n.li,{children:"A configuration service allows updating robot parameters with confirmation"}),"\n",(0,o.jsx)(n.li,{children:"A calibration service performs sensor calibration and reports results"}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Actions"})," for goal-oriented tasks:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"An arm controller action accepts reaching goals and provides progress feedback"}),"\n",(0,o.jsx)(n.li,{children:"A walking controller action manages complex locomotion with interrupt capability"}),"\n",(0,o.jsx)(n.li,{children:"A grasping action executes manipulation tasks with force feedback"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"This chapter covered the core communication patterns in ROS 2:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Nodes as the fundamental computational units"}),"\n",(0,o.jsx)(n.li,{children:"Topics for asynchronous, many-to-many communication"}),"\n",(0,o.jsx)(n.li,{children:"Services for synchronous request-response interactions"}),"\n",(0,o.jsx)(n.li,{children:"Actions for goal-oriented operations with feedback"}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"You now understand when to use each communication pattern and how they enable complex robotic behaviors in humanoid systems."}),"\n",(0,o.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(n.p,{children:"The next chapter will explore how Python-based AI agents connect to ROS 2 systems using the rclpy client library, bridging your AI development skills with robotic systems."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Continue to ",(0,o.jsx)(n.a,{href:"./chapter-3-python-integration",children:"Chapter 3: Python AI Agents and rclpy"})]}),"\n",(0,o.jsxs)(n.li,{children:["Return to ",(0,o.jsx)(n.a,{href:"./chapter-1-foundations",children:"Chapter 1: Physical AI and ROS 2 Foundations"})]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"ROS 2 Documentation: Nodes and Topics"}),"\n",(0,o.jsx)(n.li,{children:"ROS 2 Documentation: Services and Actions"}),"\n",(0,o.jsx)(n.li,{children:'"Effective Robotics Programming with ROS" by Anil Mahtani'}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453(e,n,i){i.d(n,{R:()=>r,x:()=>c});var s=i(6540);const o={},t=s.createContext(o);function r(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);